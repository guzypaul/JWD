**Два вида памяти**  
  
JVM разделяет память на две основные категории: «кучу» (heap) и «не кучу» (non-heap). Куча — это часть памяти JVM, с которой разработчики наиболее знакомы. Здесь хранятся объекты, созданные приложением. Они остаются там до тех пор, пока не будут убраны сборщиком мусора. Как правило, размер кучи, которую использует приложение, изменяется в зависимости от текущей нагрузки.  
  
Память вне кучи делится на несколько областей. В HotSpot для изучения областей этой памяти можно использовать механизм [Native memory tracking (NMT)](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html). Обратите внимание, что, хотя NMT не отслеживает использование всей нативной памяти ([например, не отслеживается выделение нативной памяти сторонним кодом](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html)), его возможностей достаточно для большинства типичных приложений на Spring. Для использования NMT запустите приложение с параметром `-XX:NativeMemoryTracking=summary` и с помощью [](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html)[jcmd VM.native_memory summary посмотрите информацию об используемой памяти.  
  
Давайте посмотрим использование NMT на примере нашего старого друга Petclinic](http://projects.spring.io/spring-petclinic/). Диаграмма ниже показывает использование памяти JVM по данным NMT (за вычетом собственного оверхеда NMT) при запуске Petclinic с максимальным размером кучи 48 МБ (`-Xmx48M`):  
  
![](https://habrastorage.org/r/w1560/webt/m8/nk/be/m8nkberjczog7bolri8lwoglbbm.png)  
  
Как вы видите, на память вне кучи приходится большая часть используемой памяти JVM, причем память кучи составляет только одну шестую часть от общего объёма. В этом случае это примерно 44 МБ (из которых 33 МБ использовалось сразу после сборки мусора). Использование памяти вне кучи составило в сумме 223 МБ.

Источник:
https://habr.com/ru/company/otus/blog/445312/


Жизненный цикл программы

Программы Java обычно проходят пять стадий обработки, прежде, чем они будут выполнены: _редактирование, компиляция, загрузка, проверка байт-кода и выполнение._ Обсудим эти концепции в контексте средства разработки J2SDK.

· редактирование файла выполняется в обычном редакторе, при сохранении на диске файлу задают расширение *.java, н-р,

myfile.java

(блокнот, Edit и т.д., возможна поддержка длинных имен файлов);

· компиляция программы осуществляется с помощью команды javac

javac [ опции ];

компилятор Java выполняет трансляцию программы в байт-код (язык интерпретатора Java). Если программа успешно откомпилируется, то компилятор создаёт файл по имени

myfile.class,

т.е. внутри файла с расширением *.class содержится текст, называемый байт-кодом;

· загрузка программы в память, выполняется загрузчиком классов, который считывает файл *.class; загрузчик классов может загружать файлы *.class двух типов: приложений и аплетов.

Апплеты – программы, с которыми пользователь соединяется с помощью браузера.

Приложения – выполняются на локальном компьютере. Они загружаются в память и выполняются интерпретатором Java, который вызывается командой

java [ опции ]

Загрузчик классов также вызывается, когда браузер загружает аплет Java. Каждый браузер имеет встроенный интерпретатор, который выполняет аплет. Апплеты могут выполняться из командной строки с помощью команды

appletviewer [ опции ]

(при этом запускается мини-браузер, который интерпретирует апплеты и игнорирует остальное содержание htm-документа).

· прежде, чем интерпретатор Java, встроенный в браузер приступит к выполнению апплета, байт-код проверяется верификатором байт-кода. Эта проверка гарантирует, что байт-коды не содержат ошибок и отсутствуют нарушения требований Java к безопасности.

· интерпретация программы, последовательное выполнение байт-кодов, выполнение действий, заложенных в программу.

В случае возникновения ошибки, необходимо вернуться к этапу редактирования и повторить выполнение всех этапов.